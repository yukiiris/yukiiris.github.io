## 1. 概述



## 2.对象

* 引用计数法
  + 难以解决对象之间互相循环引用的问题
* 可达性分析算法
  + 当一个对象到GC没有任何引用链，此对象不可用
* 引用
  + 强引用、软引用、弱引用、虚引用
* 生存还是死亡
  + 如果对象在可达性分析后被发现不可达，它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法
  + 若有必要，这个对象则会被放到**F-Queue**中缓慢执行
  + 在执行finalize（）是最后一次逃脱被销毁的机会——将自己与另一个引用链上的对象建立引用
  + finalize（）只会被执行一次
* 回收方法区



## 3. 垃圾回收算法

+ 标记-清除算法
  + 首先标记出要回收的对象，在标记完成后统一回收所有被标记的对象
  + 效率不高，标记和清除都比较慢
  + 空间问题，标记清除会产生大量不连续的内存碎片，分配大对象内存时，如果没有足够内存会再次触发垃圾收集
+ 复制算法
  + 将可用内存分为大小相等两块，当其中一块内存用完了，就把还活着的对象复制到另一块上，再将这一块一次清理完
  + 减小一半可用内存，代价太大
  + 不需要1：1划分空间
+ 标记-整理算法
  + 复制算法在存活率高的时候效率比较低
  + 标记后使其向一边移动，然后直接清理边界内存
+ 分代收集算法
  + 把内存按照对象存活周期分为几个部分，根据各个年代采用最适当的算法



## 4. HotSpot算法实现

+ 枚举根节点
  + 查找全局引用和暂停来保证一致性上会耗费很多时间
+ 安全点